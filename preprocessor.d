import std.array;
import std.stdio;
import lexer;
import parse;

class Parser {
public:
	enum State {
		Normal,
		ClassDefinition,
		MethodDefinition
	}
	
	static bool preprocess (string[] inputFiles, string outputFile, string[] includePaths) {
		File outFD;
		try {
			outFD = File(outputFile, "wt");
		} catch {
			stderr.writefln("Could not open file \"%s\" for writing.", outputFile);
			return false;
		}
		
		scope(exit) outFD.detach();
		
		outFD.writeln("// Automatically generated by the Objective-D preprocessor");
		outFD.writeln("import objd.runtime;");
		outFD.writeln();
		
		auto success = true;
		foreach (inputFile; inputFiles) {
			try {
				auto parser = new Parser(inputFile, outFD, includePaths);
				parser.parse();
			} catch (ParseException ex) {
				success = false;
			}
		}
		
		return success;
	}

protected:
	File outFD;
	string inputFile;
	string[] includePaths;
	State state;
	
	immutable(Lexeme)[] lexemes;
	string file;
	ulong line;
	
	this (string inputFile, ref File outFD, string[] includePaths) {
		this.inputFile = inputFile;
		this.outFD = outFD;
		this.includePaths = includePaths;
	}
	
	void errorOut(T...)(immutable Lexeme lexeme, T args) {
		stderr.writef("%s:%s: ", file, line);
		stderr.writef(args);
		if (lexeme !is null)
			stderr.writefln(" near %s", lexeme.content);
		else
			stderr.writeln();
		
		throw new ParseException;
	}
	
	/* Lexeme manipulation */
	immutable(Lexeme) pop () {
		if (lexemes.length == 0)
			errorOut(cast(immutable Lexeme)null, "unexpected end-of-file");
		
		auto ret = lexemes[0];
		lexemes = lexemes[1 .. $];
		
		file = ret.file;
		auto newLine = ret.line;
		
		if (newLine > line)
			// keep line numbers up-to-date
			outFD.writefln("\n#line %s \"%s\"", newLine, file);
		
		line = newLine;
		return ret;
	}
	
	immutable(Lexeme) peek () {
		if (lexemes.length == 0)
			return null;
		else
			return lexemes[0];
	}
	
	@property bool empty () {
		return lexemes.length == 0;
	}
	
	/* Semantic parsing */
	void parse () {
		lexemes = lex(inputFile);
		
		while (!empty) {
			auto lexeme = pop();
			
			switch (lexeme.token) {
			case Token.At:
				auto identifier = pop();
				if (identifier.token == Token.Identifier) {
					// this might be an Objective-D keyword
					switch (identifier.content) {
					case "class": // @class X : Y {}
						parseClass();
						continue;
					
					case "end": // @end
						parseEndBlock();
						continue;
					
					case "selector": // @selector(test:with:)
						parseSelector();
						continue;
						
					default:
						// nope, not the case
						writeLexeme(lexeme);
						writeLexeme(identifier);
						continue;
					}
				}
			
				break;
			
			case Token.LBracket:
				parseMessageSend(lexeme);
				continue;
			
			default:
				;
			}
			
			writeLexeme(lexeme);
		}
	}
	
	void parseClass () {
		if (state != State.Normal)
			errorOut(cast(immutable Lexeme)null, "unexpected @class");
	
		auto classNameL = pop();
		if (classNameL.token != Token.Identifier)
			errorOut(classNameL, "expected identifier");
		
		auto className = classNameL.content;
		outFD.writefln("\n/* Objective-D class object */\nClass %s;", className);
		
		auto next = peek();
		if (next !is null && next.token == Token.Colon) {
			// pop the token
			pop();
		
			auto inheritsL = pop();
			if (inheritsL.token != Token.Identifier)
				errorOut(inheritsL, "expected identifier");
			
			outFD.writefln("static this () { %s = new Class(\"%s\", %s); }", className, className, inheritsL.content);
		} else {
			outFD.writefln("static this () { %s = new Class(\"%s\"); }", className, className);
		}
		
		scope(exit) state = State.ClassDefinition;
		
		auto lbrace = pop();
		if (lbrace.token != Token.LBrace)
			errorOut(lbrace, "expected {");
			
		auto rbrace = pop();
		if (rbrace.token != Token.RBrace)
			errorOut(rbrace, "expected }");
	}
	
	void parseEndBlock () {
		if (state != State.ClassDefinition)
			errorOut(cast(immutable Lexeme)null, "unexpected @end");
		
		state = State.Normal;
	}
	
	bool parseMessageSend (immutable Lexeme lexeme, immutable(Lexeme)[] nested...) {
		auto receiver = pop();
		if (receiver.token != Token.Identifier && receiver.token != Token.LBracket) {
			// this is apparently *not* a message send
			foreach (parent; nested)
				writeLexeme(parent);
			
			writeLexeme(lexeme);
			writeLexeme(receiver);
			return false;
		}
		
		if (receiver.token == Token.LBracket) {
			// nested message send
			if (!parseMessageSend(receiver, nested ~ lexeme))
				return false;
		}
		
		auto firstWord = pop();
		if (firstWord.token != Token.Identifier) {
			// this is apparently *not* a message send
			foreach (parent; nested)
				writeLexeme(parent);
			
			writeLexeme(lexeme);
			writeLexeme(receiver);
			writeLexeme(firstWord);
			return false;
		}
		
		if (receiver.token == Token.Identifier) {
			// write out receiver of the message
			outFD.write(receiver.content);
		}
		
		auto selector = firstWord.content.dup;
		immutable(Lexeme)[] arguments;
		
		for (;;) {
			auto next = pop();
			if (next.token == Token.RBracket)
				break;
			else if (next.token == Token.Colon) {
				selector ~= ":";
				arguments ~= pop();
			} else if (next.token == Token.Identifier) {
				selector ~= next.content;
			} else {
				errorOut(next, "expected message name or closing bracket");
			}
		}
		
		// write out finalized message send
		outFD.writef(".msgSend!id(sel_registerName(\"%s\")", selector);
		foreach (arg; arguments) {
			outFD.write(", ");
			writeLexeme(arg);
		}
		
		outFD.writef(") ");
		return true;
	}
	
	void parseSelector () {
		auto lparen = pop();
		if (lparen.token != Token.LParen)
			errorOut(lparen, "expected (");
		
		auto firstWord = pop();
		if (firstWord.token != Token.Identifier)
			errorOut(firstWord, "expected selector name");
		
		auto selector = firstWord.content.dup;
		for (;;) {
			auto next = pop();
			if (next.token == Token.RParen)
				break;
			else if (next.token == Token.Colon)
				selector ~= ":";
			else if (next.token == Token.Identifier)
				selector ~= next.content;
			else
				errorOut(next, "expected selector name or closing parenthesis");
		}
		
		outFD.writef("sel_registerName(\"%s\") ", selector);
	}
	
	void writeLexeme (immutable Lexeme lexeme) {
		lexeme.writeToFile(outFD);
	}
}
